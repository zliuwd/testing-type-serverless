{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./index.ts","webpack:///./source-map-install.js","webpack:///./src/generated/prisma-client/index.ts","webpack:///./src/generated/prisma-client/prisma-schema.ts","webpack:///./src/resolvers/index.ts","webpack:///./src/resolvers/user.ts","webpack:///./src/restful/routes/index.ts","webpack:///./src/restful/routes/testMsg.ts","webpack:///./src/schema/index.ts","webpack:///./src/schema/userSchema.ts","webpack:///external \"apollo-server-express\"","webpack:///external \"express\"","webpack:///external \"graphql-playground-middleware-express\"","webpack:///external \"morgan\"","webpack:///external \"prisma-client-lib\"","webpack:///external \"serverless-http\"","webpack:///external \"source-map-support\""],"names":[],"mappings":"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","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import * as express from 'express';\nimport graphiql from 'graphql-playground-middleware-express';\nimport { ApolloServer } from 'apollo-server-express';\nimport * as morgan from 'morgan';\nimport serverless = require('serverless-http');\nimport schema from './src/schema';\nimport resolvers from './src/resolvers';\nimport { prisma } from './src/generated/prisma-client';\nimport restfulRoutes from './src/restful/routes';\n\nexport const app = express();\napp.use(morgan('dev'));\n\napp.use(restfulRoutes);\n\napp.disable('etag');\n\nconst server = new ApolloServer({\n  typeDefs: schema,\n  resolvers,\n  context: {\n    prisma,\n  },\n  introspection: true,\n  playground: true,\n});\n\nserver.applyMiddleware({ app });\n\napp.get('/playground', graphiql({ endpoint: '/graphql' }));\n\nconst handler = serverless(app);\n\nexport { handler };\n","require('source-map-support').install();\n","// Code generated by Prisma (prisma@1.34.7). DO NOT EDIT.\n// Please don't change this file manually but run `prisma generate` to update it.\n// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/\n\nimport { DocumentNode } from \"graphql\";\nimport {\n  makePrismaClientClass,\n  BaseClientOptions,\n  Model\n} from \"prisma-client-lib\";\nimport { typeDefs } from \"./prisma-schema\";\n\nexport type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &\n  U[keyof U];\n\nexport type Maybe<T> = T | undefined | null;\n\nexport interface Exists {\n  user: (where?: UserWhereInput) => Promise<boolean>;\n}\n\nexport interface Node {}\n\nexport type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;\n\nexport interface Fragmentable {\n  $fragment<T>(fragment: string | DocumentNode): Promise<T>;\n}\n\nexport interface Prisma {\n  $exists: Exists;\n  $graphql: <T = any>(\n    query: string,\n    variables?: { [key: string]: any }\n  ) => Promise<T>;\n\n  /**\n   * Queries\n   */\n\n  user: (where: UserWhereUniqueInput) => UserNullablePromise;\n  users: (args?: {\n    where?: UserWhereInput;\n    orderBy?: UserOrderByInput;\n    skip?: Int;\n    after?: String;\n    before?: String;\n    first?: Int;\n    last?: Int;\n  }) => FragmentableArray<User>;\n  usersConnection: (args?: {\n    where?: UserWhereInput;\n    orderBy?: UserOrderByInput;\n    skip?: Int;\n    after?: String;\n    before?: String;\n    first?: Int;\n    last?: Int;\n  }) => UserConnectionPromise;\n  node: (args: { id: ID_Output }) => Node;\n\n  /**\n   * Mutations\n   */\n\n  createUser: (data: UserCreateInput) => UserPromise;\n  updateUser: (args: {\n    data: UserUpdateInput;\n    where: UserWhereUniqueInput;\n  }) => UserPromise;\n  updateManyUsers: (args: {\n    data: UserUpdateManyMutationInput;\n    where?: UserWhereInput;\n  }) => BatchPayloadPromise;\n  upsertUser: (args: {\n    where: UserWhereUniqueInput;\n    create: UserCreateInput;\n    update: UserUpdateInput;\n  }) => UserPromise;\n  deleteUser: (where: UserWhereUniqueInput) => UserPromise;\n  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;\n\n  /**\n   * Subscriptions\n   */\n\n  $subscribe: Subscription;\n}\n\nexport interface Subscription {\n  user: (\n    where?: UserSubscriptionWhereInput\n  ) => UserSubscriptionPayloadSubscription;\n}\n\nexport interface ClientConstructor<T> {\n  new (options?: BaseClientOptions): T;\n}\n\n/**\n * Types\n */\n\nexport type UserOrderByInput =\n  | \"id_ASC\"\n  | \"id_DESC\"\n  | \"name_ASC\"\n  | \"name_DESC\"\n  | \"email_ASC\"\n  | \"email_DESC\";\n\nexport type MutationType = \"CREATED\" | \"UPDATED\" | \"DELETED\";\n\nexport interface UserCreateInput {\n  id?: Maybe<ID_Input>;\n  name: String;\n  email: String;\n}\n\nexport interface UserUpdateInput {\n  name?: Maybe<String>;\n  email?: Maybe<String>;\n}\n\nexport interface UserUpdateManyMutationInput {\n  name?: Maybe<String>;\n  email?: Maybe<String>;\n}\n\nexport interface UserWhereInput {\n  id?: Maybe<ID_Input>;\n  id_not?: Maybe<ID_Input>;\n  id_in?: Maybe<ID_Input[] | ID_Input>;\n  id_not_in?: Maybe<ID_Input[] | ID_Input>;\n  id_lt?: Maybe<ID_Input>;\n  id_lte?: Maybe<ID_Input>;\n  id_gt?: Maybe<ID_Input>;\n  id_gte?: Maybe<ID_Input>;\n  id_contains?: Maybe<ID_Input>;\n  id_not_contains?: Maybe<ID_Input>;\n  id_starts_with?: Maybe<ID_Input>;\n  id_not_starts_with?: Maybe<ID_Input>;\n  id_ends_with?: Maybe<ID_Input>;\n  id_not_ends_with?: Maybe<ID_Input>;\n  name?: Maybe<String>;\n  name_not?: Maybe<String>;\n  name_in?: Maybe<String[] | String>;\n  name_not_in?: Maybe<String[] | String>;\n  name_lt?: Maybe<String>;\n  name_lte?: Maybe<String>;\n  name_gt?: Maybe<String>;\n  name_gte?: Maybe<String>;\n  name_contains?: Maybe<String>;\n  name_not_contains?: Maybe<String>;\n  name_starts_with?: Maybe<String>;\n  name_not_starts_with?: Maybe<String>;\n  name_ends_with?: Maybe<String>;\n  name_not_ends_with?: Maybe<String>;\n  email?: Maybe<String>;\n  email_not?: Maybe<String>;\n  email_in?: Maybe<String[] | String>;\n  email_not_in?: Maybe<String[] | String>;\n  email_lt?: Maybe<String>;\n  email_lte?: Maybe<String>;\n  email_gt?: Maybe<String>;\n  email_gte?: Maybe<String>;\n  email_contains?: Maybe<String>;\n  email_not_contains?: Maybe<String>;\n  email_starts_with?: Maybe<String>;\n  email_not_starts_with?: Maybe<String>;\n  email_ends_with?: Maybe<String>;\n  email_not_ends_with?: Maybe<String>;\n  AND?: Maybe<UserWhereInput[] | UserWhereInput>;\n  OR?: Maybe<UserWhereInput[] | UserWhereInput>;\n  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;\n}\n\nexport interface UserSubscriptionWhereInput {\n  mutation_in?: Maybe<MutationType[] | MutationType>;\n  updatedFields_contains?: Maybe<String>;\n  updatedFields_contains_every?: Maybe<String[] | String>;\n  updatedFields_contains_some?: Maybe<String[] | String>;\n  node?: Maybe<UserWhereInput>;\n  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;\n  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;\n  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;\n}\n\nexport type UserWhereUniqueInput = AtLeastOne<{\n  id: Maybe<ID_Input>;\n}>;\n\nexport interface NodeNode {\n  id: ID_Output;\n}\n\nexport interface AggregateUser {\n  count: Int;\n}\n\nexport interface AggregateUserPromise\n  extends Promise<AggregateUser>,\n    Fragmentable {\n  count: () => Promise<Int>;\n}\n\nexport interface AggregateUserSubscription\n  extends Promise<AsyncIterator<AggregateUser>>,\n    Fragmentable {\n  count: () => Promise<AsyncIterator<Int>>;\n}\n\nexport interface BatchPayload {\n  count: Long;\n}\n\nexport interface BatchPayloadPromise\n  extends Promise<BatchPayload>,\n    Fragmentable {\n  count: () => Promise<Long>;\n}\n\nexport interface BatchPayloadSubscription\n  extends Promise<AsyncIterator<BatchPayload>>,\n    Fragmentable {\n  count: () => Promise<AsyncIterator<Long>>;\n}\n\nexport interface UserPreviousValues {\n  id: ID_Output;\n  name: String;\n  email: String;\n}\n\nexport interface UserPreviousValuesPromise\n  extends Promise<UserPreviousValues>,\n    Fragmentable {\n  id: () => Promise<ID_Output>;\n  name: () => Promise<String>;\n  email: () => Promise<String>;\n}\n\nexport interface UserPreviousValuesSubscription\n  extends Promise<AsyncIterator<UserPreviousValues>>,\n    Fragmentable {\n  id: () => Promise<AsyncIterator<ID_Output>>;\n  name: () => Promise<AsyncIterator<String>>;\n  email: () => Promise<AsyncIterator<String>>;\n}\n\nexport interface UserEdge {\n  node: User;\n  cursor: String;\n}\n\nexport interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {\n  node: <T = UserPromise>() => T;\n  cursor: () => Promise<String>;\n}\n\nexport interface UserEdgeSubscription\n  extends Promise<AsyncIterator<UserEdge>>,\n    Fragmentable {\n  node: <T = UserSubscription>() => T;\n  cursor: () => Promise<AsyncIterator<String>>;\n}\n\nexport interface UserSubscriptionPayload {\n  mutation: MutationType;\n  node: User;\n  updatedFields: String[];\n  previousValues: UserPreviousValues;\n}\n\nexport interface UserSubscriptionPayloadPromise\n  extends Promise<UserSubscriptionPayload>,\n    Fragmentable {\n  mutation: () => Promise<MutationType>;\n  node: <T = UserPromise>() => T;\n  updatedFields: () => Promise<String[]>;\n  previousValues: <T = UserPreviousValuesPromise>() => T;\n}\n\nexport interface UserSubscriptionPayloadSubscription\n  extends Promise<AsyncIterator<UserSubscriptionPayload>>,\n    Fragmentable {\n  mutation: () => Promise<AsyncIterator<MutationType>>;\n  node: <T = UserSubscription>() => T;\n  updatedFields: () => Promise<AsyncIterator<String[]>>;\n  previousValues: <T = UserPreviousValuesSubscription>() => T;\n}\n\nexport interface User {\n  id: ID_Output;\n  name: String;\n  email: String;\n}\n\nexport interface UserPromise extends Promise<User>, Fragmentable {\n  id: () => Promise<ID_Output>;\n  name: () => Promise<String>;\n  email: () => Promise<String>;\n}\n\nexport interface UserSubscription\n  extends Promise<AsyncIterator<User>>,\n    Fragmentable {\n  id: () => Promise<AsyncIterator<ID_Output>>;\n  name: () => Promise<AsyncIterator<String>>;\n  email: () => Promise<AsyncIterator<String>>;\n}\n\nexport interface UserNullablePromise\n  extends Promise<User | null>,\n    Fragmentable {\n  id: () => Promise<ID_Output>;\n  name: () => Promise<String>;\n  email: () => Promise<String>;\n}\n\nexport interface UserConnection {\n  pageInfo: PageInfo;\n  edges: UserEdge[];\n}\n\nexport interface UserConnectionPromise\n  extends Promise<UserConnection>,\n    Fragmentable {\n  pageInfo: <T = PageInfoPromise>() => T;\n  edges: <T = FragmentableArray<UserEdge>>() => T;\n  aggregate: <T = AggregateUserPromise>() => T;\n}\n\nexport interface UserConnectionSubscription\n  extends Promise<AsyncIterator<UserConnection>>,\n    Fragmentable {\n  pageInfo: <T = PageInfoSubscription>() => T;\n  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;\n  aggregate: <T = AggregateUserSubscription>() => T;\n}\n\nexport interface PageInfo {\n  hasNextPage: Boolean;\n  hasPreviousPage: Boolean;\n  startCursor?: String;\n  endCursor?: String;\n}\n\nexport interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {\n  hasNextPage: () => Promise<Boolean>;\n  hasPreviousPage: () => Promise<Boolean>;\n  startCursor: () => Promise<String>;\n  endCursor: () => Promise<String>;\n}\n\nexport interface PageInfoSubscription\n  extends Promise<AsyncIterator<PageInfo>>,\n    Fragmentable {\n  hasNextPage: () => Promise<AsyncIterator<Boolean>>;\n  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;\n  startCursor: () => Promise<AsyncIterator<String>>;\n  endCursor: () => Promise<AsyncIterator<String>>;\n}\n\n/*\nThe `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.\n*/\nexport type String = string;\n\nexport type Long = string;\n\n/*\nThe `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `\"4\"`) or integer (such as `4`) input value will be accepted as an ID.\n*/\nexport type ID_Input = string | number;\nexport type ID_Output = string;\n\n/*\nThe `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.\n*/\nexport type Int = number;\n\n/*\nThe `Boolean` scalar type represents `true` or `false`.\n*/\nexport type Boolean = boolean;\n\n/**\n * Model Metadata\n */\n\nexport const models: Model[] = [\n  {\n    name: \"User\",\n    embedded: false\n  }\n];\n\n/**\n * Type Defs\n */\n\nexport const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({\n  typeDefs,\n  models,\n  endpoint: `http://localhost:4466`\n});\nexport const prisma = new Prisma();\n","// Code generated by Prisma (prisma@1.34.7). DO NOT EDIT.\n  // Please don't change this file manually but run `prisma generate` to update it.\n  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/\n\nexport const typeDefs = /* GraphQL */ `type AggregateUser {\n  count: Int!\n}\n\ntype BatchPayload {\n  count: Long!\n}\n\nscalar Long\n\ntype Mutation {\n  createUser(data: UserCreateInput!): User!\n  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User\n  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!\n  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!\n  deleteUser(where: UserWhereUniqueInput!): User\n  deleteManyUsers(where: UserWhereInput): BatchPayload!\n}\n\nenum MutationType {\n  CREATED\n  UPDATED\n  DELETED\n}\n\ninterface Node {\n  id: ID!\n}\n\ntype PageInfo {\n  hasNextPage: Boolean!\n  hasPreviousPage: Boolean!\n  startCursor: String\n  endCursor: String\n}\n\ntype Query {\n  user(where: UserWhereUniqueInput!): User\n  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!\n  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!\n  node(id: ID!): Node\n}\n\ntype Subscription {\n  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload\n}\n\ntype User {\n  id: ID!\n  name: String!\n  email: String!\n}\n\ntype UserConnection {\n  pageInfo: PageInfo!\n  edges: [UserEdge]!\n  aggregate: AggregateUser!\n}\n\ninput UserCreateInput {\n  id: ID\n  name: String!\n  email: String!\n}\n\ntype UserEdge {\n  node: User!\n  cursor: String!\n}\n\nenum UserOrderByInput {\n  id_ASC\n  id_DESC\n  name_ASC\n  name_DESC\n  email_ASC\n  email_DESC\n}\n\ntype UserPreviousValues {\n  id: ID!\n  name: String!\n  email: String!\n}\n\ntype UserSubscriptionPayload {\n  mutation: MutationType!\n  node: User\n  updatedFields: [String!]\n  previousValues: UserPreviousValues\n}\n\ninput UserSubscriptionWhereInput {\n  mutation_in: [MutationType!]\n  updatedFields_contains: String\n  updatedFields_contains_every: [String!]\n  updatedFields_contains_some: [String!]\n  node: UserWhereInput\n  AND: [UserSubscriptionWhereInput!]\n  OR: [UserSubscriptionWhereInput!]\n  NOT: [UserSubscriptionWhereInput!]\n}\n\ninput UserUpdateInput {\n  name: String\n  email: String\n}\n\ninput UserUpdateManyMutationInput {\n  name: String\n  email: String\n}\n\ninput UserWhereInput {\n  id: ID\n  id_not: ID\n  id_in: [ID!]\n  id_not_in: [ID!]\n  id_lt: ID\n  id_lte: ID\n  id_gt: ID\n  id_gte: ID\n  id_contains: ID\n  id_not_contains: ID\n  id_starts_with: ID\n  id_not_starts_with: ID\n  id_ends_with: ID\n  id_not_ends_with: ID\n  name: String\n  name_not: String\n  name_in: [String!]\n  name_not_in: [String!]\n  name_lt: String\n  name_lte: String\n  name_gt: String\n  name_gte: String\n  name_contains: String\n  name_not_contains: String\n  name_starts_with: String\n  name_not_starts_with: String\n  name_ends_with: String\n  name_not_ends_with: String\n  email: String\n  email_not: String\n  email_in: [String!]\n  email_not_in: [String!]\n  email_lt: String\n  email_lte: String\n  email_gt: String\n  email_gte: String\n  email_contains: String\n  email_not_contains: String\n  email_starts_with: String\n  email_not_starts_with: String\n  email_ends_with: String\n  email_not_ends_with: String\n  AND: [UserWhereInput!]\n  OR: [UserWhereInput!]\n  NOT: [UserWhereInput!]\n}\n\ninput UserWhereUniqueInput {\n  id: ID\n}\n`","import userResolvers from './user';\n\nexport default [userResolvers];\n","import { TypeMap } from '../typeMap';\nimport { UserPromise, UserCreateInput } from '../generated/prisma-client';\n\ninterface UserDeleteById {\n  id: string;\n}\n\nexport default {\n  Query: {\n    users: (parent: TypeMap['QueryParent'], args: null, ctx: TypeMap['Context']): UserPromise => ctx.prisma.users(),\n  },\n  Mutation: {\n    signUp: (parent: TypeMap['QueryParent'], args: UserCreateInput, ctx: TypeMap['Context']): UserPromise => {\n      const newUser = ctx.prisma.createUser(args);\n\n      return newUser;\n    },\n    deleteUser: (parent: TypeMap['QueryParent'], args: UserDeleteById, ctx: TypeMap['Context']): UserPromise =>\n      ctx.prisma.deleteUser({ id: args.id }),\n  },\n};\n","import { Router } from 'express';\nimport testRoute from './testMsg';\n\nconst router = Router();\nrouter.use('/restful/test', testRoute);\nexport default router;\n","import { Router } from 'express';\nimport { TypeMap } from '../../typeMap';\n\nconst router = Router();\nrouter.get('/', (req: TypeMap['Request'], res: TypeMap['Response']) => res.send('this is the restful api return msg'));\nexport default router;\n","import { gql } from 'apollo-server-express';\n\nimport userSchema from './userSchema';\n\nconst linkSchema = gql`\n  scalar Date\n\n  type Query {\n    _: Boolean\n  }\n\n  type Mutation {\n    _: Boolean\n  }\n\n  type Subscription {\n    _: Boolean\n  }\n`;\n\nexport default [linkSchema, userSchema];\n","import { gql } from 'apollo-server-express';\n\nexport default gql`\n  extend type Query {\n    hello: String\n  }\n\n  extend type Query {\n    users: [User]\n    user(id: ID!): User\n  }\n  extend type Mutation {\n    signUp(name: String!, email: String!): User!\n\n    deleteUser(id: ID!): User!\n  }\n\n  type User {\n    id: ID!\n    name: String!\n    email: String!\n  }\n`;\n","module.exports = require(\"apollo-server-express\");","module.exports = require(\"express\");","module.exports = require(\"graphql-playground-middleware-express\");","module.exports = require(\"morgan\");","module.exports = require(\"prisma-client-lib\");","module.exports = require(\"serverless-http\");","module.exports = require(\"source-map-support\");"],"sourceRoot":""}